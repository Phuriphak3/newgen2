/*
 * LAB: Timer Interrupt Music Player with Speed Control
 * Board: ESP32
 * Core Version: 3.0+
 */

// --- 1. กำหนดขา Pin ---
const int buzzerPin = 18;  // ขาต่อ Buzzer
const int buttonPin = 19;   // ปุ่มกด (ใช้ปุ่ม BOOT บนบอร์ดได้เลย)

// --- 2. นิยามความถี่ตัวโน๊ต (อ้างอิงจากตารางโจทย์) ---
#define NOTE_G3  196
#define NOTE_C4  262
#define NOTE_E4  330
#define NOTE_F4  349
#define NOTE_FS4 370
#define NOTE_G4  392
#define NOTE_GS4 415
#define NOTE_A4  440
#define NOTE_AS4 466 // Bb4
#define NOTE_B4  494
#define NOTE_C5  523
#define NOTE_CS5 554
#define NOTE_D5  587
#define NOTE_DS5 622 // Eb5
#define NOTE_E5  659
#define NOTE_F5  698
#define NOTE_FS5 740
#define NOTE_G5  784
#define REST     0
#define NOTE_DS4 311

// --- 3. โครงสร้างเพลง (โน๊ต และ จังหวะ) ---
// เพลง: Super Mario Bros Theme (Intro)
int melody[] = {
 NOTE_G4, NOTE_G4, NOTE_G4, NOTE_DS4, NOTE_AS4, NOTE_G4, NOTE_DS4, NOTE_AS4, NOTE_G4, 
  REST,
  // ท่อน 2: ตื่อ(สูง) ตือ(สูง) ตือ(สูง)... ตื่อ(สูง) ตึ๊ด(ต่ำ) ตือ...
  NOTE_D5, NOTE_D5, NOTE_D5, NOTE_DS5, NOTE_AS4, NOTE_FS4, NOTE_DS4, NOTE_AS4, NOTE_G4
};

// จังหวะของแต่ละโน๊ต (ค่ายิ่งน้อยยิ่งเล่นเร็ว)
// 12 = ปกติ, 6 = ครึ่งจังหวะ
int noteDurations[] = {
  4, 4, 4, 8, 8, 4, 8, 8, 2,
  8, // หยุดนิดนึง
  // ท่อน 2
  4, 4, 4, 8, 8, 4, 8, 8, 2
};

int totalNotes = sizeof(melody) / sizeof(int);

// --- 4. ตัวแปร Global สำหรับ Timer และ Speed ---
hw_timer_t *timer = NULL;
volatile bool toggle = false;
volatile int speedLevel = 2; // เริ่มต้นที่ระดับ 2 (ปกติ)
// ระดับความเร็ว: 0=ช้ามาก, 1=ช้า, 2=ปกติ, 3=เร็ว, 4=เร็วมาก
const char* speedNames[] = {"Very Slow", "Slow", "Normal", "Fast", "Very Fast"};
float speedMultipliers[] = {2.0, 1.5, 1.0, 0.75, 0.5}; // ตัวคูณเวลา (ยิ่งมากยิ่งช้า)

// ตัวแปรกันเบิ้ลปุ่ม (Debounce)
volatile unsigned long lastButtonTime = 0; 
const unsigned long debounceDelay = 200; // 200ms

// --- 5. Interrupt Service Routines (ISRs) ---

// ISR 1: สร้างคลื่นเสียง (Timer Interrupt)
// ทำหน้าที่สลับสถานะขา High/Low เพื่อสร้าง Square Wave
void ARDUINO_ISR_ATTR onTimer() {
  toggle = !toggle;
  digitalWrite(buzzerPin, toggle);
}

// ISR 2: ปุ่มกดเปลี่ยนความเร็ว (I/O Interrupt)
void ARDUINO_ISR_ATTR onButtonPress() {
  unsigned long currentTime = millis();
  // เช็ค Debounce
  if (currentTime - lastButtonTime > debounceDelay) {
    speedLevel++;
    if (speedLevel > 4) {
      speedLevel = 0; // วนกลับไปช้ามาก
    }
    lastButtonTime = currentTime;
    // พิมพ์บอกสถานะ (ใน ISR ไม่ควรใช้ Serial แต่ใช้เพื่อ Debug เล็กน้อยได้)
    // หรือใช้วิธี set flag ไปทำใน loop ก็ได้ แต่นี่ทำแบบง่าย
  }
}

// --- 6. ฟังก์ชันควบคุมเสียง ---

void stopTone() {
  if (timer) {
    timerStop(timer); // หยุด Timer
  }
  digitalWrite(buzzerPin, LOW); // ปิดเสียงเงียบ
}

void playTone(int frequency) {
  if (frequency == 0) { // ถ้าเป็นตัวหยุด (REST)
    stopTone();
    return;
  }

  // คำนวณค่า Alarm สำหรับ Timer 1MHz
  // สูตร: 1,000,000 / (2 * frequency)
  uint64_t alarmVal = 1000000 / (2 * frequency);

  // ตั้งค่า Alarm และเริ่ม Timer
  timerAlarm(timer, alarmVal, true, 0);
  timerStart(timer);
}

// --- 7. Setup ---

void setup() {
  Serial.begin(115200);
  pinMode(buzzerPin, OUTPUT);
  
  // ตั้งค่าปุ่มกดแบบ Pull-up และต่อ Interrupt
  pinMode(buttonPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(buttonPin), onButtonPress, FALLING);

  // ตั้งค่า Timer (ESP32 Core v3.0)
  // ใช้ความถี่ฐาน 1MHz (1 tick = 1 microsecond)
  timer = timerBegin(1000000);
  timerAttachInterrupt(timer, &onTimer);

  Serial.println("System Ready. Press BOOT button to change speed.");
}

// --- 8. Loop (เล่นเพลงวนไป) ---

void loop() {
  static int lastPrintedSpeed = -1;

  // แสดงผลความเร็วปัจจุบันทาง Serial Monitor
  if (lastPrintedSpeed != speedLevel) {
    Serial.print("Current Speed: ");
    Serial.println(speedNames[speedLevel]);
    lastPrintedSpeed = speedLevel;
  }

  // วนลูปเล่นโน๊ตทีละตัว
  for (int i = 0; i < totalNotes; i++) {
    
    // ตรวจสอบว่าความเร็วเปลี่ยนกลางเพลงไหม (เพื่อให้เห็นผลทันที)
    if (lastPrintedSpeed != speedLevel) {
       Serial.print("Speed Changed to: ");
       Serial.println(speedNames[speedLevel]);
       lastPrintedSpeed = speedLevel;
    }

    // คำนวณระยะเวลาของโน๊ตตามความเร็วปัจจุบัน
    // duration 120ms เป็นฐาน คูณด้วย speedMultiplier
    int durationBase = 1200 / noteDurations[i]; // แปลงค่าจังหวะเป็น ms
    int realDuration = durationBase * speedMultipliers[speedLevel];

    // เล่นเสียง
    playTone(melody[i]);
    
    // รอจนกว่าจะจบโน๊ต
    delay(realDuration);

    // หยุดเสียงเล็กน้อยระหว่างตัวโน๊ตเพื่อให้เสียงขาดจากกัน (Articulation)
    stopTone();
    delay(realDuration * 0.30); // หยุดพัก 30% ของความยาวโน๊ต
  }
  
  // พัก 1 วินาทีก่อนเล่นเพลงซ้ำ
  delay(1000);
}
